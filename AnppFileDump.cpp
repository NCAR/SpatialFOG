// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
// ** Copyright UCAR (c) 1990 - 2016                                         
// ** University Corporation for Atmospheric Research (UCAR)                 
// ** National Center for Atmospheric Research (NCAR)                        
// ** Boulder, Colorado, USA                                                 
// ** BSD licence applies - redistribution and use in source and binary      
// ** forms, with or without modification, are permitted provided that       
// ** the following conditions are met:                                      
// ** 1) If the software is modified to produce derivative works,            
// ** such modified software should be clearly marked, so as not             
// ** to confuse it with the version available from UCAR.                    
// ** 2) Redistributions of source code must retain the above copyright      
// ** notice, this list of conditions and the following disclaimer.          
// ** 3) Redistributions in binary form must reproduce the above copyright   
// ** notice, this list of conditions and the following disclaimer in the    
// ** documentation and/or other materials provided with the distribution.   
// ** 4) Neither the name of UCAR nor the names of its contributors,         
// ** if any, may be used to endorse or promote products derived from        
// ** this software without specific prior written permission.               
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS  
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* 
/*
 * AnppFileDump.cpp
 *
 *  Created on: Sep 21, 2016
 *      Author: Chris Burghart <burghart@ucar.edu>
 */

/// Dump selected information from files of Advanced Navigation Packet
/// Protocol (ANPP) packets, as generated by the Advanced Navigation Spatial
/// FOG INS.
#include <cerrno>
#include <cstring>
#include <fcntl.h>
#include <iomanip>
#include <sstream>
#include <unistd.h>
#include <logx/Logging.h>
#include <sys/types.h>

#include "AnppPacketFactory.h"

#include <QByteArray>
#include <QDateTime>

LOGGING("AnppFileDump");

// Data read, but not yet parsed
QByteArray _data;

// Total bytes skipped looking for valid packet headers
int _nskipped = 0;

// Count of packets processed
int _packetsProcessed = 0;

// Forwards
void parseAndProcessData();
void processPacket(const AnppPacket & pkt);

int
main(int argc, char * argv[]) {
    // Initialize logx, letting it get and strip out its own arguments
    logx::ParseLogArgs(argc, argv);

    // The rest of the arguments should be file names
    int nFiles = argc - 1;
    char ** fileNames = argv + 1;

    char newData[256];
    for (int f = 0; f < nFiles; f++) {
        int fd = open(fileNames[f], O_RDONLY);
        if (fd < 0) {
            // Log the open error, and continue to the next file
            ELOG << "Error opening " << fileNames[f] << ": " <<
                    strerror(errno);
            continue;
        }
        
        while (true) {
            // Read more bytes
            int nread = read(fd, newData, sizeof(newData));
            if (nread == 0) {
                DLOG << "End of file " << fileNames[f];
                break;  // go to the next file
            } else if (nread < 0) {
                ELOG << "Read error on " << fileNames[f] << ": " <<
                        strerror(errno);
                break;  // go to the next file
            }

            // Append the bytes to our unparsed data, then parse and process
            // what we can.
            _data.append(newData, nread);
            parseAndProcessData();
        }
    }
}


// Parse and process valid packets from the head of _data, removing them as
// they are successfully parsed.
void
parseAndProcessData() {
    // Extract and process any valid ANPP packets at the head of _data
    while (_data.length() > 0) {
        // Cast our data into a pointer to an array of uint8_t
        const uint8_t* uint8Data = reinterpret_cast<uint8_t*>(_data.data());
        uint dataLen(_data.length());

        try {
            // Let the ANPPPacketFactory try to create a packet
            AnppPacket * pkt =
                    AnppPacketFactory::ConstructAnppPacket(uint8Data, dataLen);
            if (_nskipped) {
                WLOG << "Skipped " << _nskipped <<
                        " bytes to find a pkt (after " <<
                        _packetsProcessed << " pkts received)";
                _nskipped = 0;
            }

            // process the packet
            processPacket(*pkt);
            _packetsProcessed++;

            // Drop the bytes from the packet we just decoded from the front
            // of _data
            _data.remove(0, pkt->fullPacketLen());

            // Delete the packet
            delete(pkt);

            continue;
        } catch (AnppPacket::NeedMoreData & x) {
            // Break out, since the factory needs more data to continue
            DLOG << "Waiting for more data: " << x.what();
            break;
        } catch (AnppPacket::BadHeader & x) {
            DLOG << "Bad header: " << x.what() << "; skipping a byte";
            // Our data does not begin with a valid header. Drop the first
            // byte of _data and try again.
            _data.remove(0, 1);
            _nskipped++;

            // Early on, log every multiple of 100 skipped bytes. Later report
            // every 1000. With good data, we should never have to skip more
            // than 255 bytes to find a valid header.
            if (_nskipped < 1000 && (_nskipped % 100) == 0) {
                WLOG << "Looking for a header; " << _nskipped <<
                        " bytes skipped so far...";
            } else if ((_nskipped % 1000) == 0) {
                ELOG << "Still no good header after " << _nskipped <<
                        " bytes. Maybe bad baud rate is yielding garbled data?";
            }
            continue;
        }
    }
}

const char _TrueChar[] = "+";
const char _FalseChar[] = "-";

inline const char *
boolChar(bool state) {
    return(state ? _TrueChar : _FalseChar);
}

std::string
packetTimeString(const AnppPacket & pkt) {
    QDateTime pktTime = QDateTime::fromTime_t(pkt.timeOfValiditySeconds())
                        .addMSecs(pkt.timeOfValidityMicroseconds() / 1000)
                        .toUTC();
    return(pktTime.toString("yyyy/MM/dd hh:mm:ss.zzz").toStdString());
}

void
doDeviceInformationPacket(const DeviceInformationPacket & diPkt) {
    std::cout << packetTimeString(diPkt) << " Device Information - ";
    std::cout << diPkt.deviceName();
    std::cout << ", s/w version: " << diPkt.softwareVersion();
    std::cout << ", h/w rev: " << diPkt.hardwareRevision();
    std::cout << std::endl;
}

void
doSystemStatePacket(const SystemStatePacket & ssPkt) {
    std::cout << packetTimeString(ssPkt) << " System State - ";

    // initialization bits
    std::cout << "init: ";
    std::cout << (ssPkt.utcTimeInitialized() ? "T" : "-");
    std::cout << (ssPkt.headingInitialized() ? "H" : "-");
    std::cout << (ssPkt.navigationFilterInitialized() ? "N" : "-");
    std::cout << (ssPkt.orientationFilterInitialized() ? "O" : "-");

    // GNSS fix
    std::cout << ", fix: " << ssPkt.gnssFixString();
        
    // last pitch and roll
    std::cout << ", pitch: " <<
            std::fixed << std::setprecision(2) <<
            ssPkt.pitch();
    std::cout << ", roll: " <<
            std::fixed << std::setprecision(2) <<
            ssPkt.roll();

    std::cout << std::endl;
}

void
doSatellitesPacket(const SatellitesPacket & pkt) {
    std::cout << packetTimeString(pkt) << " Satellites - ";

    // satellites seen
    std::cout << "GPS: " << pkt.nGps() <<
                 ", GLONASS: " << pkt.nGlonass() <<
                 ", BeiDou: " << pkt.nBeiDou() <<
                 ", Galileo: " << pkt.nGalileo() <<
                 " SBAS: " << pkt.nSbas() <<
                 std::endl;
}

void
doDetailedSatellitesPacket(const DetailedSatellitesPacket & pkt) {
    int nSatellites = pkt.nSatellites();

    // packet time
    QDateTime pktTime = QDateTime::fromTime_t(pkt.timeOfValiditySeconds())
                        .addMSecs(pkt.timeOfValidityMicroseconds() / 1000)
                        .toUTC();
    std::cout << pktTime.toString("yyyy/MM/dd hh:mm:ss.zzz ").toStdString();
    std::cout << "Detailed Satellites - ";

    // SNR stats
    int snrMax = -99;
    float snrSum = 0.0;
    for (int i = 0; i < nSatellites; i++) {
        int snr = pkt.snrForIndex(i);
        if (snr > snrMax) {
            snrMax = snr;
        }
        snrSum += snr;
    }
    float snrMean = (nSatellites > 0) ? snrSum / nSatellites : -99.0;

    // overall info
    std::cout << "tracking " << nSatellites << ", SNR max: " <<
            snrMax << ", SNR mean: " << snrMean << std::endl;

//    // per-satellite info
//    for (int i = 0; i < nSatellites; i++) {
//        std::cout << "    " << i + 1 << ": " << pkt.systemNameForIndex(i) <<
//                " " << pkt.satNumForIndex(i) << " SNR: " <<
//                pkt.snrForIndex(i) << std::endl;
//    }
}

void
processPacket(const AnppPacket & pkt) {
    switch (pkt.packetId()) {
    case 3:
    {
        // Handle DeviceInformationPacket
        const DeviceInformationPacket * diPkt = 
                dynamic_cast<const DeviceInformationPacket*>(&pkt);
        if (diPkt) {
            doDeviceInformationPacket(*diPkt);
        } else {
            ELOG << "Packet with ID 3 won't cast to DeviceInformationPacket!";
        }
        break;
    }
    case 20:
    {
        // Handle SystemStatePacket
        const SystemStatePacket * ssPkt = dynamic_cast<const SystemStatePacket*>(&pkt);
        if (ssPkt) {
            doSystemStatePacket(*ssPkt);
        } else {
            ELOG << "Packet with ID 20 won't cast to SystemStatePacket!";
        }
        break;
    }
    case 30:
    {
        const SatellitesPacket * sPkt = dynamic_cast<const SatellitesPacket*>(&pkt);
        if (sPkt) {
            doSatellitesPacket(*sPkt);
        } else {
            ELOG << "Packet with ID 30 won't cast to SatellitesPacket";
        }
        break;
    }
    case 31:
    {
        const DetailedSatellitesPacket * dsPkt = 
                dynamic_cast<const DetailedSatellitesPacket*>(&pkt);
        if (dsPkt) {
            doDetailedSatellitesPacket(*dsPkt);
        } else {
            ELOG << "Packet with ID 31 won't cast to DetailedSatellitesPacket";
        }
        break;
    }
    default:
        std::cout << packetTimeString(pkt);
        std::cout << " packet ID " << pkt.packetId();
        std::cout << ", data length " << pkt.packetDataLen() << std::endl;
    }
}
